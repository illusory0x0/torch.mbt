///|
enum ElementKind {
  // Uint8
  // Int8
  Int16
  Int
  Int64
  // Half
  Float
  Double
  // ComplexHalf
  // ComplexFloat
  // ComplexDouble
  // Bool
  // QInt8
  // QUInt8
  // QInt32
  // BFloat16
  // Float8e5m2
  // Float8e4m3fn
  // Float8e5m2fnuz
  // Float8e4m3fnuz
}

///|
trait Element {
  kind(Self) -> ElementKind
  elt_size_in_bytes(Self) -> UInt
  c_int(Self) -> Int
  bytes(Array[Self]) -> Bytes
  to_vec(Bytes) -> Array[Self]
}

///|
impl Element with elt_size_in_bytes(self) {
  match self.kind() {
    // ElementKind::Uint8 => 1
    // ElementKind::Int8 => 1
    ElementKind::Int16 => 2
    ElementKind::Int => 4
    ElementKind::Int64 => 8
    // ElementKind::Half => 2
    ElementKind::Float => 4
    ElementKind::Double => 8
    // ElementKind::ComplexHalf => 4
    // ElementKind::ComplexFloat => 8
    // ElementKind::ComplexDouble => 16
    // ElementKind::Bool => 1
    // ElementKind::QInt8 => 1
    // ElementKind::QUInt8 => 1
    // ElementKind::QInt32 => 4
    // ElementKind::BFloat16 => 2
    // ElementKind::Float8e5m2 => 1
    // ElementKind::Float8e4m3fn => 1
    // ElementKind::Float8e5m2fnuz => 1
    // ElementKind::Float8e4m3fnuz => 1
  }
}

// These values should be in sync with include/c10/core/ScalarType.h
///|
impl Element with c_int(self) {
  match self.kind() {
    // ElementKind::Uint8 => 0
    // ElementKind::Int8 => 1
    ElementKind::Int16 => 2
    ElementKind::Int => 3
    ElementKind::Int64 => 4
    // ElementKind::Half => 5
    ElementKind::Float => 6
    ElementKind::Double => 7
    // ElementKind::ComplexHalf => 8
    // ElementKind::ComplexFloat => 9
    // ElementKind::ComplexDouble => 10
    // ElementKind::Bool => 11
    // ElementKind::QInt8 => 12
    // ElementKind::QUInt8 => 13
    // ElementKind::QInt32 => 14
    // ElementKind::BFloat16 => 15
    // ElementKind::Float8e5m2 => 23
    // ElementKind::Float8e4m3fn => 24
    // ElementKind::Float8e5m2fnuz => 25
    // ElementKind::Float8e4m3fnuz => 26
  }
}

///|
impl Element for Int16 with kind(_) {
  ElementKind::Int16
}

///|
impl Element for Int16 with bytes(arr) {
  int_16_array_to_bytes(arr)
}

///|
impl Element for Int16 with to_vec(bytes) {
  bytes_to_int_16_array(bytes)
}

///|
impl Element for Int with kind(_) {
  ElementKind::Int
}

///|
impl Element for Int with bytes(arr) {
  int_array_to_bytes(arr)
}

///|
impl Element for Int with to_vec(bytes) {
  bytes_to_int_array(bytes)
}

///|
impl Element for Int64 with kind(_) {
  ElementKind::Int64
}

///|
impl Element for Int64 with bytes(arr) {
  int_64_array_to_bytes(arr)
}

///|
impl Element for Int64 with to_vec(bytes) {
  bytes_to_int_64_array(bytes)
}

///|
impl Element for Float with kind(_) {
  ElementKind::Float
}

///|
impl Element for Float with bytes(arr) {
  float_array_to_bytes(arr)
}

///|
impl Element for Float with to_vec(bytes) {
  bytes_to_float_array(bytes)
}

///|
impl Element for Double with kind(_) {
  ElementKind::Double
}

///|
impl Element for Double with bytes(arr) {
  double_array_to_bytes(arr)
}

///|
impl Element for Double with to_vec(bytes) {
  bytes_to_double_array(bytes)
}

///|
struct Tensor[T] {
  id : Int64
}

///|
pub fn reshape[T](self : Tensor[T], dims : Array[Int]) -> Tensor[T] {
  let ndims = dims.length().reinterpret_as_uint()
  let dims = dims.map(fn(x) { x.to_int64() }) |> int_64_array_to_bytes
  let id = reshape_ffi(self.id, dims, ndims)
  { id, }
}

///|
pub fn op_add[A](self : Tensor[A], other : Tensor[A]) -> Tensor[A] {
  let id = add_tensors_ffi(self.id, other.id)
  { id, }
}

///|
pub fn op_sub[A](self : Tensor[A], other : Tensor[A]) -> Tensor[A] {
  let id = sub_tensors_ffi(self.id, other.id)
  { id, }
}

///|
pub fn op_neg[A](self : Tensor[A]) -> Tensor[A] {
  let id = neg_tensor_ffi(self.id)
  { id, }
}

///|
pub fn op_equal[A](self : Tensor[A], other : Tensor[A]) -> Bool {
  equal_tensors_ffi(self.id, other.id) == 1
}

///|
pub fn op_mul[A](self : Tensor[A], other : Tensor[A]) -> Tensor[A] {
  let id = mul_tensors_ffi(self.id, other.id)
  { id, }
}

///|
pub fn matmul[A](self : Tensor[A], other : Tensor[A]) -> Tensor[A] {
  let id = matmul_tensors_ffi(self.id, other.id)
  { id, }
}

///|
pub fn transpose[T](self : Tensor[T]) -> Tensor[T] {
  let id = transpose_tensor_ffi(self.id)
  { id, }
}

///|
pub fn drop[T](self : Tensor[T]) -> Unit {
  drop_torch_object(self.id)
}

///|
impl[T : Element + Show] Show for Tensor[T] with output(self, logger) {
  let shape = (get_tensor_shape_ffi(self.id) |> bytes_to_int_array).rev()
  let vec = T::to_vec(get_tensor_raw_ffi(self.id))
  logger.write_string("Tensor(")
  let n = vec.length()
  let shape_len = shape.length()
  for i in 0..<n {
    let mut left_cnt = 0
    let mut right_cnt = 0
    let mut index = i
    for j in 0..<shape_len {
      let dim = shape[j]
      let index_in_dim = index % dim
      if index_in_dim == 0 {
        left_cnt += 1
      } else {
        break
      }
      index = index / dim
    }
    index = i
    for j in 0..<shape_len {
      let dim = shape[j]
      let index_in_dim = index % dim
      if index_in_dim == dim - 1 {
        right_cnt += 1
      } else {
        break
      }
      index = index / dim
    }
    logger.write_string("[".repeat(left_cnt))
    logger.write_string(vec[i].to_string())
    logger.write_string("]".repeat(right_cnt))
    if i < n - 1 {
      logger.write_string(", ")
    }
  }
  logger.write_string(")")
}

///|
fn at_tensor_of_data[T](
  data_ptr : Bytes,
  dims : Array[Int],
  ndims : UInt,
  element_size_in_bytes : UInt,
  _type : Int
) -> Tensor[T] {
  let dims = dims.map(fn(x) { x.to_int64() }) |> int_64_array_to_bytes
  let id = at_tensor_of_data_ffi(
    data_ptr, dims, ndims, element_size_in_bytes, _type,
  )
  { id, }
}

///|
fn tensor_from_array[T : Element](arr : Array[T]) -> Tensor[T] {
  let raw = T::bytes(arr)
  at_tensor_of_data(
    raw,
    [arr.length()],
    1,
    arr[0].elt_size_in_bytes(),
    arr[0].c_int(),
  )
}

///|
fn tensor_from_file[T : Element](path : String) -> Tensor[T] {
  let path = mbt_string_to_utf8_bytes(path, true)
  let id = load_tensor_from_file_ffi(path)
  { id, }
}

///|
test "tensor" {
  let tensor_a = tensor_from_array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])
  inspect!(tensor_a, content="Tensor([1, 2, 3, 4, 5, 6])")
  let tensor_b = tensor_from_array([1, 2, 3])
  inspect!(tensor_b, content="Tensor([1, 2, 3])")
  tensor_a.drop()
  tensor_b.drop()
}

///|
test "tensor_add" {
  let tensor_a = tensor_from_array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])
  let tensor_b = tensor_from_array([6.0, 5.0, 4.0, 3.0, 2.0, 1.0])
  let tensor_c = tensor_a + tensor_b
  inspect!(tensor_c, content="Tensor([7, 7, 7, 7, 7, 7])")
  tensor_a.drop()
  tensor_b.drop()
  tensor_c.drop()
}

///|
test "tensor_neg" {
  let tensor_a = tensor_from_array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])
  let tensor_b = -tensor_a
  inspect!(tensor_b, content="Tensor([-1, -2, -3, -4, -5, -6])")
  tensor_a.drop()
  tensor_b.drop()
}

///|
test "tensor_sub" {
  let tensor_a = tensor_from_array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])
  let tensor_b = tensor_from_array([6.0, 5.0, 4.0, 3.0, 2.0, 1.0])
  let tensor_c = tensor_a - tensor_b
  inspect!(tensor_c, content="Tensor([-5, -3, -1, 1, 3, 5])")
  tensor_a.drop()
  tensor_b.drop()
  tensor_c.drop()
}

///|
test "tensor_mul" {
  let tensor_a = tensor_from_array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])
  let tensor_b = tensor_from_array([6.0, 5.0, 4.0, 3.0, 2.0, 1.0])
  let tensor_c = tensor_a * tensor_b
  inspect!(tensor_c, content="Tensor([6, 10, 12, 12, 10, 6])")
  tensor_a.drop()
  tensor_b.drop()
  tensor_c.drop()
}

///|
test "tensor_matmul" {
  let tensor_a = tensor_from_array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])
  let tensor_b = tensor_from_array([6.0, 5.0, 4.0, 3.0, 2.0, 1.0])
  let reshape_b = tensor_b.reshape([6, 1])
  let tensor_c = tensor_a.matmul(reshape_b)
  inspect!(tensor_c, content="Tensor([56])")
  tensor_a.drop()
  tensor_b.drop()
  reshape_b.drop()
  tensor_c.drop()
}

///|
test "tensor_transpose" {
  let tensor_a = tensor_from_array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])
  let reshape_a = tensor_a.reshape([2, 3])
  let tensor_b = reshape_a.transpose()
  inspect!(tensor_b, content="Tensor([[1, 4], [2, 5], [3, 6]])")
  tensor_a.drop()
  reshape_a.drop()
  tensor_b.drop()
}

///|
test "tensor_allclose" {
  let tensor_a = tensor_from_array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])
  let tensor_b = tensor_from_array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])
  let tensor_c = tensor_from_array([6.0, 5.0, 4.0, 3.0, 2.0, 1.0])
  assert_true!(tensor_a == tensor_b)
  assert_false!(tensor_a == tensor_c)
  tensor_a.drop()
  tensor_b.drop()
  tensor_c.drop()
}

///|
test "reshape" {
  let tensor_a = tensor_from_array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])
  let tensor_b = tensor_a.reshape([2, 3])
  inspect!(tensor_b, content="Tensor([[1, 2, 3], [4, 5, 6]])")
  tensor_a.drop()
  tensor_b.drop()
}
